# frozen_string_literal: true

# Code generated by protoc-gen-protobug. DO NOT EDIT.

# source: google/protobuf/descriptor.proto
# syntax: proto2
# package: google.protobuf
# options:
#   java_package: "com.google.protobuf"
#   java_outer_classname: "DescriptorProtos"
#   optimize_for: SPEED
#   go_package: "google.golang.org/protobuf/types/descriptorpb"
#   cc_enable_arenas: true
#   objc_class_prefix: "GPB"
#   csharp_namespace: "Google.Protobuf.Reflection"

# Protocol Buffers - Google's data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Author: kenton@google.com (Kenton Varda)
#  Based on original Protocol Buffers design by
#  Sanjay Ghemawat, Jeff Dean, and others.
#
# The messages in this file describe the definitions found in .proto files.
# A valid .proto file can be translated directly to a FileDescriptorProto
# without any other information (e.g. without reading its imports).

require "protobug"

module Google
  module Protobuf
    # The protocol compiler can output a FileDescriptorSet containing the .proto
    # files it parses.
    class FileDescriptorSet
      extend Protobug::Message

      self.full_name = "google.protobuf.FileDescriptorSet"

      repeated(
        1,
        "file",
        type: :message,
        message_type: "google.protobuf.FileDescriptorProto"
      )
    end

    # The full set of known editions.
    class Edition
      extend Protobug::Enum

      self.full_name = "google.protobuf.Edition"

      # A placeholder for an unknown edition value.
      EDITION_UNKNOWN = new("EDITION_UNKNOWN", 0).freeze
      # Legacy syntax "editions".  These pre-date editions, but behave much like
      # distinct editions.  These can't be used to specify the edition of proto
      # files, but feature definitions must supply proto2/proto3 defaults for
      # backwards compatibility.
      EDITION_PROTO2 = new("EDITION_PROTO2", 998).freeze
      EDITION_PROTO3 = new("EDITION_PROTO3", 999).freeze
      # Editions that have been released.  The specific values are arbitrary and
      # should not be depended on, but they will always be time-ordered for easy
      # comparison.
      EDITION_2023 = new("EDITION_2023", 1000).freeze
      EDITION_2024 = new("EDITION_2024", 1001).freeze
      # Placeholder editions for testing feature resolution.  These should not be
      # used or relyed on outside of tests.
      EDITION_1_TEST_ONLY = new("EDITION_1_TEST_ONLY", 1).freeze
      EDITION_2_TEST_ONLY = new("EDITION_2_TEST_ONLY", 2).freeze
      EDITION_99997_TEST_ONLY = new("EDITION_99997_TEST_ONLY", 99997).freeze
      EDITION_99998_TEST_ONLY = new("EDITION_99998_TEST_ONLY", 99998).freeze
      EDITION_99999_TEST_ONLY = new("EDITION_99999_TEST_ONLY", 99999).freeze
      # Placeholder for specifying unbounded edition support.  This should only
      # ever be used by plugins that can expect to never require any changes to
      # support a new edition.
      EDITION_MAX = new("EDITION_MAX", 2147483647).freeze
    end

    # Describes a complete .proto file.
    class FileDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.FileDescriptorProto"

      optional(
        1,
        "name",
        type: :string
      ) # file name, relative to root of source tree
      optional(2, "package", type: :string) # e.g. "foo", "foo.bar", etc.
      # Names of files imported by this file.
      repeated(3, "dependency", type: :string)
      # Indexes of the public imported files in the dependency list above.
      repeated(
        10,
        "public_dependency",
        type: :int32,
        json_name: "publicDependency"
      )
      # Indexes of the weak imported files in the dependency list.
      # For Google-internal migration only. Do not use.
      repeated(11, "weak_dependency", type: :int32, json_name: "weakDependency")
      # All top-level definitions in this file.
      repeated(
        4,
        "message_type",
        type: :message,
        message_type: "google.protobuf.DescriptorProto",
        json_name: "messageType"
      )
      repeated(
        5,
        "enum_type",
        type: :message,
        message_type: "google.protobuf.EnumDescriptorProto",
        json_name: "enumType"
      )
      repeated(
        6,
        "service",
        type: :message,
        message_type: "google.protobuf.ServiceDescriptorProto"
      )
      repeated(
        7,
        "extension",
        type: :message,
        message_type: "google.protobuf.FieldDescriptorProto"
      )
      optional(
        8,
        "options",
        type: :message,
        message_type: "google.protobuf.FileOptions"
      )
      # This field contains optional information about the original source code.
      # You may safely remove this entire field without harming runtime
      # functionality of the descriptors -- the information is needed only by
      # development tools.
      optional(
        9,
        "source_code_info",
        type: :message,
        message_type: "google.protobuf.SourceCodeInfo",
        json_name: "sourceCodeInfo"
      )
      # The syntax of the proto file.
      # The supported values are "proto2", "proto3", and "editions".
      #
      # If `edition` is present, this value must be "editions".
      optional(12, "syntax", type: :string)
      # The edition of the proto file.
      optional(14, "edition", type: :enum, enum_type: "google.protobuf.Edition")
    end

    # Describes a message type.
    class DescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.DescriptorProto"

      optional(1, "name", type: :string)
      repeated(
        2,
        "field",
        type: :message,
        message_type: "google.protobuf.FieldDescriptorProto"
      )
      repeated(
        6,
        "extension",
        type: :message,
        message_type: "google.protobuf.FieldDescriptorProto"
      )
      repeated(
        3,
        "nested_type",
        type: :message,
        message_type: "google.protobuf.DescriptorProto",
        json_name: "nestedType"
      )
      repeated(
        4,
        "enum_type",
        type: :message,
        message_type: "google.protobuf.EnumDescriptorProto",
        json_name: "enumType"
      )
      class ExtensionRange
        extend Protobug::Message

        self.full_name = "google.protobuf.DescriptorProto.ExtensionRange"

        optional(1, "start", type: :int32) # Inclusive.
        optional(2, "end", type: :int32) # Exclusive.
        optional(
          3,
          "options",
          type: :message,
          message_type: "google.protobuf.ExtensionRangeOptions"
        )
      end

      repeated(
        5,
        "extension_range",
        type: :message,
        message_type: "google.protobuf.DescriptorProto.ExtensionRange",
        json_name: "extensionRange"
      )
      repeated(
        8,
        "oneof_decl",
        type: :message,
        message_type: "google.protobuf.OneofDescriptorProto",
        json_name: "oneofDecl"
      )
      optional(
        7,
        "options",
        type: :message,
        message_type: "google.protobuf.MessageOptions"
      )
      # Range of reserved tag numbers. Reserved tag numbers may not be used by
      # fields or extension ranges in the same message. Reserved ranges may
      # not overlap.
      class ReservedRange
        extend Protobug::Message

        self.full_name = "google.protobuf.DescriptorProto.ReservedRange"

        optional(1, "start", type: :int32) # Inclusive.
        optional(2, "end", type: :int32) # Exclusive.
      end

      repeated(
        9,
        "reserved_range",
        type: :message,
        message_type: "google.protobuf.DescriptorProto.ReservedRange",
        json_name: "reservedRange"
      )
      # Reserved field names, which may not be used by fields in the same message.
      # A given name may only be reserved once.
      repeated(10, "reserved_name", type: :string, json_name: "reservedName")
    end

    class ExtensionRangeOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.ExtensionRangeOptions"

      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )
      class Declaration
        extend Protobug::Message

        self.full_name = "google.protobuf.ExtensionRangeOptions.Declaration"

        # The extension number declared within the extension range.
        optional(1, "number", type: :int32)
        # The fully-qualified name of the extension field. There must be a leading
        # dot in front of the full name.
        optional(2, "full_name", type: :string, json_name: "fullName")
        # The fully-qualified type name of the extension field. Unlike
        # Metadata.type, Declaration.type must have a leading dot for messages
        # and enums.
        optional(3, "type", type: :string)
        # If true, indicates that the number is reserved in the extension range,
        # and any extension field with the number will fail to compile. Set this
        # when a declared extension field is deleted.
        optional(5, "reserved", type: :bool)
        # If true, indicates that the extension must be defined as repeated.
        # Otherwise the extension must be defined as optional.
        optional(6, "repeated", type: :bool)

        reserved_range(4...5)
      end

      # For external users: DO NOT USE. We are in the process of open sourcing
      # extension declaration and executing internal cleanups before it can be
      # used externally.
      repeated(
        2,
        "declaration",
        type: :message,
        message_type: "google.protobuf.ExtensionRangeOptions.Declaration"
      )
      # Any features defined in the specific edition.
      optional(
        50,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The verification state of the extension range.
      class VerificationState
        extend Protobug::Enum

        self.full_name = "google.protobuf.ExtensionRangeOptions.VerificationState"

        # All the extensions of the range must be declared.
        DECLARATION = new("DECLARATION", 0).freeze
        UNVERIFIED = new("UNVERIFIED", 1).freeze
      end

      # The verification state of the range.
      # TODO: flip the default to DECLARATION once all empty ranges
      # are marked as UNVERIFIED.
      optional(
        3,
        "verification",
        type: :enum,
        enum_type: "google.protobuf.ExtensionRangeOptions.VerificationState"
      )
    end

    # Describes a field within a message.
    class FieldDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.FieldDescriptorProto"

      class Type
        extend Protobug::Enum

        self.full_name = "google.protobuf.FieldDescriptorProto.Type"

        # 0 is reserved for errors.
        # Order is weird for historical reasons.
        TYPE_DOUBLE = new("TYPE_DOUBLE", 1).freeze
        TYPE_FLOAT = new("TYPE_FLOAT", 2).freeze
        # Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
        # negative values are likely.
        TYPE_INT64 = new("TYPE_INT64", 3).freeze
        TYPE_UINT64 = new("TYPE_UINT64", 4).freeze
        # Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
        # negative values are likely.
        TYPE_INT32 = new("TYPE_INT32", 5).freeze
        TYPE_FIXED64 = new("TYPE_FIXED64", 6).freeze
        TYPE_FIXED32 = new("TYPE_FIXED32", 7).freeze
        TYPE_BOOL = new("TYPE_BOOL", 8).freeze
        TYPE_STRING = new("TYPE_STRING", 9).freeze
        # Tag-delimited aggregate.
        # Group type is deprecated and not supported after google.protobuf. However, Proto3
        # implementations should still be able to parse the group wire format and
        # treat group fields as unknown fields.  In Editions, the group wire format
        # can be enabled via the `message_encoding` feature.
        TYPE_GROUP = new("TYPE_GROUP", 10).freeze
        TYPE_MESSAGE = new(
          "TYPE_MESSAGE",
          11
        ).freeze # Length-delimited aggregate.
        # New in version 2.
        TYPE_BYTES = new("TYPE_BYTES", 12).freeze
        TYPE_UINT32 = new("TYPE_UINT32", 13).freeze
        TYPE_ENUM = new("TYPE_ENUM", 14).freeze
        TYPE_SFIXED32 = new("TYPE_SFIXED32", 15).freeze
        TYPE_SFIXED64 = new("TYPE_SFIXED64", 16).freeze
        TYPE_SINT32 = new("TYPE_SINT32", 17).freeze # Uses ZigZag encoding.
        TYPE_SINT64 = new("TYPE_SINT64", 18).freeze # Uses ZigZag encoding.
      end

      class Label
        extend Protobug::Enum

        self.full_name = "google.protobuf.FieldDescriptorProto.Label"

        # 0 is reserved for errors
        LABEL_OPTIONAL = new("LABEL_OPTIONAL", 1).freeze
        LABEL_REPEATED = new("LABEL_REPEATED", 3).freeze
        # The required label is only allowed in google.protobuf.  In proto3 and Editions
        # it's explicitly prohibited.  In Editions, the `field_presence` feature
        # can be used to get this behavior.
        LABEL_REQUIRED = new("LABEL_REQUIRED", 2).freeze
      end

      optional(1, "name", type: :string)
      optional(3, "number", type: :int32)
      optional(
        4,
        "label",
        type: :enum,
        enum_type: "google.protobuf.FieldDescriptorProto.Label"
      )
      # If type_name is set, this need not be set.  If both this and type_name
      # are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
      optional(
        5,
        "type",
        type: :enum,
        enum_type: "google.protobuf.FieldDescriptorProto.Type"
      )
      # For message and enum types, this is the name of the type.  If the name
      # starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
      # rules are used to find the type (i.e. first the nested types within this
      # message are searched, then within the parent, on up to the root
      # namespace).
      optional(6, "type_name", type: :string, json_name: "typeName")
      # For extensions, this is the name of the type being extended.  It is
      # resolved in the same manner as type_name.
      optional(2, "extendee", type: :string)
      # For numeric types, contains the original text representation of the value.
      # For booleans, "true" or "false".
      # For strings, contains the default text contents (not escaped in any way).
      # For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
      optional(7, "default_value", type: :string, json_name: "defaultValue")
      # If set, gives the index of a oneof in the containing type's oneof_decl
      # list.  This field is a member of that oneof.
      optional(9, "oneof_index", type: :int32, json_name: "oneofIndex")
      # JSON name of this field. The value is set by protocol compiler. If the
      # user has set a "json_name" option on this field, that option's value
      # will be used. Otherwise, it's deduced from the field's name by converting
      # it to camelCase.
      optional(10, "json_name", type: :string, json_name: "jsonName")
      optional(
        8,
        "options",
        type: :message,
        message_type: "google.protobuf.FieldOptions"
      )
      # If true, this is a proto3 "optional". When a proto3 field is optional, it
      # tracks presence regardless of field type.
      #
      # When proto3_optional is true, this field must belong to a oneof to signal
      # to old proto3 clients that presence is tracked for this field. This oneof
      # is known as a "synthetic" oneof, and this field must be its sole member
      # (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs
      # exist in the descriptor only, and do not generate any API. Synthetic oneofs
      # must be ordered after all "real" oneofs.
      #
      # For message fields, proto3_optional doesn't create any semantic change,
      # since non-repeated message fields always track presence. However it still
      # indicates the semantic detail of whether the user wrote "optional" or not.
      # This can be useful for round-tripping the .proto file. For consistency we
      # give message fields a synthetic oneof also, even though it is not required
      # to track presence. This is especially important because the parser can't
      # tell if a field is a message or an enum, so it must always create a
      # synthetic oneof.
      #
      # Proto2 optional fields do not set this flag, because they already indicate
      # optional with `LABEL_OPTIONAL`.
      optional(17, "proto3_optional", type: :bool, json_name: "proto3Optional")
    end

    # Describes a oneof.
    class OneofDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.OneofDescriptorProto"

      optional(1, "name", type: :string)
      optional(
        2,
        "options",
        type: :message,
        message_type: "google.protobuf.OneofOptions"
      )
    end

    # Describes an enum type.
    class EnumDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.EnumDescriptorProto"

      optional(1, "name", type: :string)
      repeated(
        2,
        "value",
        type: :message,
        message_type: "google.protobuf.EnumValueDescriptorProto"
      )
      optional(
        3,
        "options",
        type: :message,
        message_type: "google.protobuf.EnumOptions"
      )
      # Range of reserved numeric values. Reserved values may not be used by
      # entries in the same enum. Reserved ranges may not overlap.
      #
      # Note that this is distinct from DescriptorProto.ReservedRange in that it
      # is inclusive such that it can appropriately represent the entire int32
      # domain.
      class EnumReservedRange
        extend Protobug::Message

        self.full_name = "google.protobuf.EnumDescriptorProto.EnumReservedRange"

        optional(1, "start", type: :int32) # Inclusive.
        optional(2, "end", type: :int32) # Inclusive.
      end

      # Range of reserved numeric values. Reserved numeric values may not be used
      # by enum values in the same enum declaration. Reserved ranges may not
      # overlap.
      repeated(
        4,
        "reserved_range",
        type: :message,
        message_type: "google.protobuf.EnumDescriptorProto.EnumReservedRange",
        json_name: "reservedRange"
      )
      # Reserved enum value names, which may not be reused. A given name may only
      # be reserved once.
      repeated(5, "reserved_name", type: :string, json_name: "reservedName")
    end

    # Describes a value within an enum.
    class EnumValueDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.EnumValueDescriptorProto"

      optional(1, "name", type: :string)
      optional(2, "number", type: :int32)
      optional(
        3,
        "options",
        type: :message,
        message_type: "google.protobuf.EnumValueOptions"
      )
    end

    # Describes a service.
    class ServiceDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.ServiceDescriptorProto"

      optional(1, "name", type: :string)
      repeated(
        2,
        "method",
        type: :message,
        message_type: "google.protobuf.MethodDescriptorProto"
      )
      optional(
        3,
        "options",
        type: :message,
        message_type: "google.protobuf.ServiceOptions"
      )
    end

    # Describes a method of a service.
    class MethodDescriptorProto
      extend Protobug::Message

      self.full_name = "google.protobuf.MethodDescriptorProto"

      optional(1, "name", type: :string)
      # Input and output type names.  These are resolved in the same way as
      # FieldDescriptorProto.type_name, but must refer to a message type.
      optional(2, "input_type", type: :string, json_name: "inputType")
      optional(3, "output_type", type: :string, json_name: "outputType")
      optional(
        4,
        "options",
        type: :message,
        message_type: "google.protobuf.MethodOptions"
      )
      # Identifies if client streams multiple client messages
      optional(5, "client_streaming", type: :bool, json_name: "clientStreaming")
      # Identifies if server streams multiple server messages
      optional(6, "server_streaming", type: :bool, json_name: "serverStreaming")
    end

    # ===================================================================
    # Options

    # Each of the definitions above may have "options" attached.  These are
    # just annotations which may cause code to be generated slightly differently
    # or may contain hints for code that manipulates protocol messages.
    #
    # Clients may define custom options as extensions of the *Options messages.
    # These extensions may not yet be known at parsing time, so the parser cannot
    # store the values in them.  Instead it stores them in a field in the *Options
    # message called uninterpreted_option. This field must have the same name
    # across all *Options messages. We then use this field to populate the
    # extensions when we build a descriptor, at which point all protos have been
    # parsed and so all extensions are known.
    #
    # Extension numbers for custom options may be chosen as follows:
    # * For options which will only be used within a single application or
    #   organization, or for experimental options, use field numbers 50000
    #   through 99999.  It is up to you to ensure that you do not use the
    #   same number for multiple options.
    # * For options which will be published and used publicly by multiple
    #   independent entities, e-mail protobuf-global-extension-registry@google.com
    #   to reserve extension numbers. Simply provide your project name (e.g.
    #   Objective-C plugin) and your project website (if available) -- there's no
    #   need to explain how you intend to use them. Usually you only need one
    #   extension number. You can declare multiple options with only one extension
    #   number by putting them in a sub-message. See the Custom Options section of
    #   the docs for examples:
    #   https://developers.google.com/protocol-buffers/docs/proto#options
    #   If this turns out to be popular, a web service will be set up
    #   to automatically assign option numbers.

    class FileOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.FileOptions"

      # Sets the Java package where classes generated from this .proto will be
      # placed.  By default, the proto package is used, but this is often
      # inappropriate because proto packages do not normally start with backwards
      # domain names.
      optional(1, "java_package", type: :string, json_name: "javaPackage")
      # Controls the name of the wrapper Java class generated for the .proto file.
      # That class will always contain the .proto file's getDescriptor() method as
      # well as any top-level extensions defined in the .proto file.
      # If java_multiple_files is disabled, then all the other classes from the
      # .proto file will be nested inside the single wrapper outer class.
      optional(
        8,
        "java_outer_classname",
        type: :string,
        json_name: "javaOuterClassname"
      )
      # If enabled, then the Java code generator will generate a separate .java
      # file for each top-level message, enum, and service defined in the .proto
      # file.  Thus, these types will *not* be nested inside the wrapper class
      # named by java_outer_classname.  However, the wrapper class will still be
      # generated to contain the file's getDescriptor() method as well as any
      # top-level extensions defined in the file.
      optional(
        10,
        "java_multiple_files",
        type: :bool,
        json_name: "javaMultipleFiles"
      )
      # This option does nothing.
      optional(
        20,
        "java_generate_equals_and_hash",
        type: :bool,
        json_name: "javaGenerateEqualsAndHash"
      )
      # A proto2 file can set this to true to opt in to UTF-8 checking for Java,
      # which will throw an exception if invalid UTF-8 is parsed from the wire or
      # assigned to a string field.
      #
      # TODO: clarify exactly what kinds of field types this option
      # applies to, and update these docs accordingly.
      #
      # Proto3 files already perform these checks. Setting the option explicitly to
      # false has no effect: it cannot be used to opt proto3 files out of UTF-8
      # checks.
      optional(
        27,
        "java_string_check_utf8",
        type: :bool,
        json_name: "javaStringCheckUtf8"
      )
      # Generated classes can be optimized for speed or code size.
      class OptimizeMode
        extend Protobug::Enum

        self.full_name = "google.protobuf.FileOptions.OptimizeMode"

        SPEED = new(
          "SPEED",
          1
        ).freeze # Generate complete code for parsing, serialization,
        # etc.
        CODE_SIZE = new(
          "CODE_SIZE",
          2
        ).freeze # Use ReflectionOps to implement these methods.
        LITE_RUNTIME = new(
          "LITE_RUNTIME",
          3
        ).freeze # Generate code using MessageLite and the lite runtime.
      end

      optional(
        9,
        "optimize_for",
        type: :enum,
        enum_type: "google.protobuf.FileOptions.OptimizeMode",
        json_name: "optimizeFor"
      )
      # Sets the Go package where structs generated from this .proto will be
      # placed. If omitted, the Go package will be derived from the following:
      #   - The basename of the package import path, if provided.
      #   - Otherwise, the package statement in the .proto file, if present.
      #   - Otherwise, the basename of the .proto file, without extension.
      optional(11, "go_package", type: :string, json_name: "goPackage")
      # Should generic services be generated in each language?  "Generic" services
      # are not specific to any particular RPC system.  They are generated by the
      # main code generators in each language (without additional plugins).
      # Generic services were the only kind of service generation supported by
      # early versions of google.protobuf.
      #
      # Generic services are now considered deprecated in favor of using plugins
      # that generate code specific to your particular RPC system.  Therefore,
      # these default to false.  Old code which depends on generic services should
      # explicitly set them to true.
      optional(
        16,
        "cc_generic_services",
        type: :bool,
        json_name: "ccGenericServices"
      )
      optional(
        17,
        "java_generic_services",
        type: :bool,
        json_name: "javaGenericServices"
      )
      optional(
        18,
        "py_generic_services",
        type: :bool,
        json_name: "pyGenericServices"
      )
      # Is this file deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for everything in the file, or it will be completely ignored; in the very
      # least, this is a formalization for deprecating files.
      optional(23, "deprecated", type: :bool)
      # Enables the use of arenas for the proto messages in this file. This applies
      # only to generated classes for C++.
      optional(31, "cc_enable_arenas", type: :bool, json_name: "ccEnableArenas")
      # Sets the objective c class prefix which is prepended to all objective c
      # generated classes from this .proto. There is no default.
      optional(
        36,
        "objc_class_prefix",
        type: :string,
        json_name: "objcClassPrefix"
      )
      # Namespace for generated classes; defaults to the package.
      optional(
        37,
        "csharp_namespace",
        type: :string,
        json_name: "csharpNamespace"
      )
      # By default Swift generators will take the proto package and CamelCase it
      # replacing '.' with underscore and use that to prefix the types/symbols
      # defined. When this options is provided, they will use this value instead
      # to prefix the types/symbols defined.
      optional(39, "swift_prefix", type: :string, json_name: "swiftPrefix")
      # Sets the php class prefix which is prepended to all php generated classes
      # from this .proto. Default is empty.
      optional(
        40,
        "php_class_prefix",
        type: :string,
        json_name: "phpClassPrefix"
      )
      # Use this option to change the namespace of php generated classes. Default
      # is empty. When this option is empty, the package name will be used for
      # determining the namespace.
      optional(41, "php_namespace", type: :string, json_name: "phpNamespace")
      # Use this option to change the namespace of php generated metadata classes.
      # Default is empty. When this option is empty, the proto file name will be
      # used for determining the namespace.
      optional(
        44,
        "php_metadata_namespace",
        type: :string,
        json_name: "phpMetadataNamespace"
      )
      # Use this option to change the package of ruby generated classes. Default
      # is empty. When this option is not set, the package name will be used for
      # determining the ruby package.
      optional(45, "ruby_package", type: :string, json_name: "rubyPackage")
      # Any features defined in the specific edition.
      optional(
        50,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The parser stores options it doesn't recognize here.
      # See the documentation for the "Options" section above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )

      reserved_range(42...43)
      reserved_range(38...39)
    end

    class MessageOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.MessageOptions"

      # Set true to use the old proto1 MessageSet wire format for extensions.
      # This is provided for backwards-compatibility with the MessageSet wire
      # format.  You should not use this for any other reason:  It's less
      # efficient, has fewer features, and is more complicated.
      #
      # The message must be defined exactly as follows:
      #   message Foo {
      #     option message_set_wire_format = true;
      #     extensions 4 to max;
      #   }
      # Note that the message cannot have any defined fields; MessageSets only
      # have extensions.
      #
      # All extensions of your type must be singular messages; e.g. they cannot
      # be int32s, enums, or repeated messages.
      #
      # Because this is an option, the above two restrictions are not enforced by
      # the protocol compiler.
      optional(
        1,
        "message_set_wire_format",
        type: :bool,
        json_name: "messageSetWireFormat"
      )
      # Disables the generation of the standard "descriptor()" accessor, which can
      # conflict with a field of the same name.  This is meant to make migration
      # from proto1 easier; new code should avoid fields named "descriptor".
      optional(
        2,
        "no_standard_descriptor_accessor",
        type: :bool,
        json_name: "noStandardDescriptorAccessor"
      )
      # Is this message deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for the message, or it will be completely ignored; in the very least,
      # this is a formalization for deprecating messages.
      optional(3, "deprecated", type: :bool)
      # Whether the message is an automatically generated map entry type for the
      # maps field.
      #
      # For maps fields:
      #     map<KeyType, ValueType> map_field = 1;
      # The parsed descriptor looks like:
      #     message MapFieldEntry {
      #         option map_entry = true;
      #         optional KeyType key = 1;
      #         optional ValueType value = 2;
      #     }
      #     repeated MapFieldEntry map_field = 1;
      #
      # Implementations may choose not to generate the map_entry=true message, but
      # use a native map in the target language to hold the keys and values.
      # The reflection APIs in such implementations still need to work as
      # if the field is a repeated message field.
      #
      # NOTE: Do not set the option in .proto files. Always use the maps syntax
      # instead. The option should only be implicitly set by the proto compiler
      # parser.
      optional(7, "map_entry", type: :bool, json_name: "mapEntry")
      # Enable the legacy handling of JSON field name conflicts.  This lowercases
      # and strips underscored from the fields before comparison in proto3 only.
      # The new behavior takes `json_name` into account and applies to proto2 as
      # well.
      #
      # This should only be used as a temporary measure against broken builds due
      # to the change in behavior for JSON field name conflicts.
      #
      # TODO This is legacy behavior we plan to remove once downstream
      # teams have had time to migrate.
      optional(
        11,
        "deprecated_legacy_json_field_conflicts",
        type: :bool,
        json_name: "deprecatedLegacyJsonFieldConflicts"
      )
      # Any features defined in the specific edition.
      optional(
        12,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )

      reserved_range(4...5)
      reserved_range(5...6)
      reserved_range(6...7)
      reserved_range(8...9)
      reserved_range(9...10)
    end

    class FieldOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.FieldOptions"

      # The ctype option instructs the C++ code generator to use a different
      # representation of the field than it normally would.  See the specific
      # options below.  This option is only implemented to support use of
      # [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
      # type "bytes" in the open source release -- sorry, we'll try to include
      # other types in a future version!
      optional(
        1,
        "ctype",
        type: :enum,
        enum_type: "google.protobuf.FieldOptions.CType"
      )
      class CType
        extend Protobug::Enum

        self.full_name = "google.protobuf.FieldOptions.CType"

        # Default mode.
        STRING = new("STRING", 0).freeze
        # The option [ctype=CORD] may be applied to a non-repeated field of type
        # "bytes". It indicates that in C++, the data should be stored in a Cord
        # instead of a string.  For very large strings, this may reduce memory
        # fragmentation. It may also allow better performance when parsing from a
        # Cord, or when parsing with aliasing enabled, as the parsed Cord may then
        # alias the original buffer.
        CORD = new("CORD", 1).freeze
        STRING_PIECE = new("STRING_PIECE", 2).freeze
      end

      # The packed option can be enabled for repeated primitive fields to enable
      # a more efficient representation on the wire. Rather than repeatedly
      # writing the tag and type for each element, the entire array is encoded as
      # a single length-delimited blob. In proto3, only explicit setting it to
      # false will avoid using packed encoding.  This option is prohibited in
      # Editions, but the `repeated_field_encoding` feature can be used to control
      # the behavior.
      optional(2, "packed", type: :bool)
      # The jstype option determines the JavaScript type used for values of the
      # field.  The option is permitted only for 64 bit integral and fixed types
      # (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
      # is represented as JavaScript string, which avoids loss of precision that
      # can happen when a large value is converted to a floating point JavaScript.
      # Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
      # use the JavaScript "number" type.  The behavior of the default option
      # JS_NORMAL is implementation dependent.
      #
      # This option is an enum to permit additional types to be added, e.g.
      # goog.math.Integer.
      optional(
        6,
        "jstype",
        type: :enum,
        enum_type: "google.protobuf.FieldOptions.JSType"
      )
      class JSType
        extend Protobug::Enum

        self.full_name = "google.protobuf.FieldOptions.JSType"

        # Use the default type.
        JS_NORMAL = new("JS_NORMAL", 0).freeze
        # Use JavaScript strings.
        JS_STRING = new("JS_STRING", 1).freeze
        # Use JavaScript numbers.
        JS_NUMBER = new("JS_NUMBER", 2).freeze
      end

      # Should this field be parsed lazily?  Lazy applies only to message-type
      # fields.  It means that when the outer message is initially parsed, the
      # inner message's contents will not be parsed but instead stored in encoded
      # form.  The inner message will actually be parsed when it is first accessed.
      #
      # This is only a hint.  Implementations are free to choose whether to use
      # eager or lazy parsing regardless of the value of this option.  However,
      # setting this option true suggests that the protocol author believes that
      # using lazy parsing on this field is worth the additional bookkeeping
      # overhead typically needed to implement it.
      #
      # This option does not affect the public interface of any generated code;
      # all method signatures remain the same.  Furthermore, thread-safety of the
      # interface is not affected by this option; const methods remain safe to
      # call from multiple threads concurrently, while non-const methods continue
      # to require exclusive access.
      #
      # Note that lazy message fields are still eagerly verified to check
      # ill-formed wireformat or missing required fields. Calling IsInitialized()
      # on the outer message would fail if the inner message has missing required
      # fields. Failed verification would result in parsing failure (except when
      # uninitialized messages are acceptable).
      optional(5, "lazy", type: :bool)
      # unverified_lazy does no correctness checks on the byte stream. This should
      # only be used where lazy with verification is prohibitive for performance
      # reasons.
      optional(15, "unverified_lazy", type: :bool, json_name: "unverifiedLazy")
      # Is this field deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for accessors, or it will be completely ignored; in the very least, this
      # is a formalization for deprecating fields.
      optional(3, "deprecated", type: :bool)
      # For Google-internal migration only. Do not use.
      optional(10, "weak", type: :bool)
      # Indicate that the field value should not be printed out when using debug
      # formats, e.g. when the field contains sensitive credentials.
      optional(16, "debug_redact", type: :bool, json_name: "debugRedact")
      # If set to RETENTION_SOURCE, the option will be omitted from the binary.
      # Note: as of January 2023, support for this is in progress and does not yet
      # have an effect (b/264593489).
      class OptionRetention
        extend Protobug::Enum

        self.full_name = "google.protobuf.FieldOptions.OptionRetention"

        RETENTION_UNKNOWN = new("RETENTION_UNKNOWN", 0).freeze
        RETENTION_RUNTIME = new("RETENTION_RUNTIME", 1).freeze
        RETENTION_SOURCE = new("RETENTION_SOURCE", 2).freeze
      end

      optional(
        17,
        "retention",
        type: :enum,
        enum_type: "google.protobuf.FieldOptions.OptionRetention"
      )
      # This indicates the types of entities that the field may apply to when used
      # as an option. If it is unset, then the field may be freely used as an
      # option on any kind of entity. Note: as of January 2023, support for this is
      # in progress and does not yet have an effect (b/264593489).
      class OptionTargetType
        extend Protobug::Enum

        self.full_name = "google.protobuf.FieldOptions.OptionTargetType"

        TARGET_TYPE_UNKNOWN = new("TARGET_TYPE_UNKNOWN", 0).freeze
        TARGET_TYPE_FILE = new("TARGET_TYPE_FILE", 1).freeze
        TARGET_TYPE_EXTENSION_RANGE = new(
          "TARGET_TYPE_EXTENSION_RANGE",
          2
        ).freeze
        TARGET_TYPE_MESSAGE = new("TARGET_TYPE_MESSAGE", 3).freeze
        TARGET_TYPE_FIELD = new("TARGET_TYPE_FIELD", 4).freeze
        TARGET_TYPE_ONEOF = new("TARGET_TYPE_ONEOF", 5).freeze
        TARGET_TYPE_ENUM = new("TARGET_TYPE_ENUM", 6).freeze
        TARGET_TYPE_ENUM_ENTRY = new("TARGET_TYPE_ENUM_ENTRY", 7).freeze
        TARGET_TYPE_SERVICE = new("TARGET_TYPE_SERVICE", 8).freeze
        TARGET_TYPE_METHOD = new("TARGET_TYPE_METHOD", 9).freeze
      end

      repeated(
        19,
        "targets",
        type: :enum,
        enum_type: "google.protobuf.FieldOptions.OptionTargetType"
      )
      class EditionDefault
        extend Protobug::Message

        self.full_name = "google.protobuf.FieldOptions.EditionDefault"

        optional(
          3,
          "edition",
          type: :enum,
          enum_type: "google.protobuf.Edition"
        )
        optional(2, "value", type: :string) # Textproto value.
      end

      repeated(
        20,
        "edition_defaults",
        type: :message,
        message_type: "google.protobuf.FieldOptions.EditionDefault",
        json_name: "editionDefaults"
      )
      # Any features defined in the specific edition.
      optional(
        21,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )

      reserved_range(4...5)
      reserved_range(18...19)
    end

    class OneofOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.OneofOptions"

      # Any features defined in the specific edition.
      optional(
        1,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )
    end

    class EnumOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.EnumOptions"

      # Set this option to true to allow mapping different tag names to the same
      # value.
      optional(2, "allow_alias", type: :bool, json_name: "allowAlias")
      # Is this enum deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for the enum, or it will be completely ignored; in the very least, this
      # is a formalization for deprecating enums.
      optional(3, "deprecated", type: :bool)
      # Enable the legacy handling of JSON field name conflicts.  This lowercases
      # and strips underscored from the fields before comparison in proto3 only.
      # The new behavior takes `json_name` into account and applies to proto2 as
      # well.
      # TODO Remove this legacy behavior once downstream teams have
      # had time to migrate.
      optional(
        6,
        "deprecated_legacy_json_field_conflicts",
        type: :bool,
        json_name: "deprecatedLegacyJsonFieldConflicts"
      )
      # Any features defined in the specific edition.
      optional(
        7,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )

      reserved_range(5...6)
    end

    class EnumValueOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.EnumValueOptions"

      # Is this enum value deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for the enum value, or it will be completely ignored; in the very least,
      # this is a formalization for deprecating enum values.
      optional(1, "deprecated", type: :bool)
      # Any features defined in the specific edition.
      optional(
        2,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # Indicate that fields annotated with this enum value should not be printed
      # out when using debug formats, e.g. when the field contains sensitive
      # credentials.
      optional(3, "debug_redact", type: :bool, json_name: "debugRedact")
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )
    end

    class ServiceOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.ServiceOptions"

      # Any features defined in the specific edition.
      optional(
        34,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # NOTE: Field numbers 1 through 32 are reserved for Google's internal RPC
      #   framework.  We apologize for hoarding these numbers to ourselves, but
      #   we were already using them long before we decided to release Protocol
      #   Buffers.

      # Is this service deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for the service, or it will be completely ignored; in the very least,
      # this is a formalization for deprecating services.
      optional(33, "deprecated", type: :bool)
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )
    end

    class MethodOptions
      extend Protobug::Message

      self.full_name = "google.protobuf.MethodOptions"

      # NOTE: Field numbers 1 through 32 are reserved for Google's internal RPC
      #   framework.  We apologize for hoarding these numbers to ourselves, but
      #   we were already using them long before we decided to release Protocol
      #   Buffers.

      # Is this method deprecated?
      # Depending on the target platform, this can emit Deprecated annotations
      # for the method, or it will be completely ignored; in the very least,
      # this is a formalization for deprecating methods.
      optional(33, "deprecated", type: :bool)
      # Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
      # or neither? HTTP based RPC implementation may choose GET verb for safe
      # methods, and PUT verb for idempotent methods instead of the default POST.
      class IdempotencyLevel
        extend Protobug::Enum

        self.full_name = "google.protobuf.MethodOptions.IdempotencyLevel"

        IDEMPOTENCY_UNKNOWN = new("IDEMPOTENCY_UNKNOWN", 0).freeze
        NO_SIDE_EFFECTS = new("NO_SIDE_EFFECTS", 1).freeze # implies idempotent
        IDEMPOTENT = new(
          "IDEMPOTENT",
          2
        ).freeze # idempotent, but may have side effects
      end

      optional(
        34,
        "idempotency_level",
        type: :enum,
        enum_type: "google.protobuf.MethodOptions.IdempotencyLevel",
        json_name: "idempotencyLevel"
      )
      # Any features defined in the specific edition.
      optional(
        35,
        "features",
        type: :message,
        message_type: "google.protobuf.FeatureSet"
      )
      # The parser stores options it doesn't recognize here. See above.
      repeated(
        999,
        "uninterpreted_option",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption",
        json_name: "uninterpretedOption"
      )
    end

    # A message representing a option the parser does not recognize. This only
    # appears in options protos created by the compiler::Parser class.
    # DescriptorPool resolves these when building Descriptor objects. Therefore,
    # options protos in descriptor objects (e.g. returned by Descriptor::options(),
    # or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
    # in them.
    class UninterpretedOption
      extend Protobug::Message

      self.full_name = "google.protobuf.UninterpretedOption"

      # The name of the uninterpreted option.  Each string represents a segment in
      # a dot-separated name.  is_extension is true iff a segment represents an
      # extension (denoted with parentheses in options specs in .proto files).
      # E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
      # "foo.(bar.baz).moo".
      class NamePart
        extend Protobug::Message

        self.full_name = "google.protobuf.UninterpretedOption.NamePart"

        required(1, "name_part", type: :string, json_name: "namePart")
        required(2, "is_extension", type: :bool, json_name: "isExtension")
      end

      repeated(
        2,
        "name",
        type: :message,
        message_type: "google.protobuf.UninterpretedOption.NamePart"
      )
      # The value of the uninterpreted option, in whatever type the tokenizer
      # identified it as during parsing. Exactly one of these should be set.
      optional(
        3,
        "identifier_value",
        type: :string,
        json_name: "identifierValue"
      )
      optional(
        4,
        "positive_int_value",
        type: :uint64,
        json_name: "positiveIntValue"
      )
      optional(
        5,
        "negative_int_value",
        type: :int64,
        json_name: "negativeIntValue"
      )
      optional(6, "double_value", type: :double, json_name: "doubleValue")
      optional(7, "string_value", type: :bytes, json_name: "stringValue")
      optional(8, "aggregate_value", type: :string, json_name: "aggregateValue")
    end

    # ===================================================================
    # Features

    # TODO: Enums in C++ gencode (and potentially other languages) are
    # not well scoped.  This means that each of the feature enums below can clash
    # with each other.  The short names we've chosen maximize call-site
    # readability, but leave us very open to this scenario.  A future feature will
    # be designed and implemented to handle this, hopefully before we ever hit a
    # conflict here.
    class FeatureSet
      extend Protobug::Message

      self.full_name = "google.protobuf.FeatureSet"

      class FieldPresence
        extend Protobug::Enum

        self.full_name = "google.protobuf.FeatureSet.FieldPresence"

        FIELD_PRESENCE_UNKNOWN = new("FIELD_PRESENCE_UNKNOWN", 0).freeze
        EXPLICIT = new("EXPLICIT", 1).freeze
        IMPLICIT = new("IMPLICIT", 2).freeze
        LEGACY_REQUIRED = new("LEGACY_REQUIRED", 3).freeze
      end

      optional(
        1,
        "field_presence",
        type: :enum,
        enum_type: "google.protobuf.FeatureSet.FieldPresence",
        json_name: "fieldPresence"
      )
      class EnumType
        extend Protobug::Enum

        self.full_name = "google.protobuf.FeatureSet.EnumType"

        ENUM_TYPE_UNKNOWN = new("ENUM_TYPE_UNKNOWN", 0).freeze
        OPEN = new("OPEN", 1).freeze
        CLOSED = new("CLOSED", 2).freeze
      end

      optional(
        2,
        "enum_type",
        type: :enum,
        enum_type: "google.protobuf.FeatureSet.EnumType",
        json_name: "enumType"
      )
      class RepeatedFieldEncoding
        extend Protobug::Enum

        self.full_name = "google.protobuf.FeatureSet.RepeatedFieldEncoding"

        REPEATED_FIELD_ENCODING_UNKNOWN = new(
          "REPEATED_FIELD_ENCODING_UNKNOWN",
          0
        ).freeze
        PACKED = new("PACKED", 1).freeze
        EXPANDED = new("EXPANDED", 2).freeze
      end

      optional(
        3,
        "repeated_field_encoding",
        type: :enum,
        enum_type: "google.protobuf.FeatureSet.RepeatedFieldEncoding",
        json_name: "repeatedFieldEncoding"
      )
      class Utf8Validation
        extend Protobug::Enum

        self.full_name = "google.protobuf.FeatureSet.Utf8Validation"

        UTF8_VALIDATION_UNKNOWN = new("UTF8_VALIDATION_UNKNOWN", 0).freeze
        VERIFY = new("VERIFY", 2).freeze
        NONE = new("NONE", 3).freeze
      end

      optional(
        4,
        "utf8_validation",
        type: :enum,
        enum_type: "google.protobuf.FeatureSet.Utf8Validation",
        json_name: "utf8Validation"
      )
      class MessageEncoding
        extend Protobug::Enum

        self.full_name = "google.protobuf.FeatureSet.MessageEncoding"

        MESSAGE_ENCODING_UNKNOWN = new("MESSAGE_ENCODING_UNKNOWN", 0).freeze
        LENGTH_PREFIXED = new("LENGTH_PREFIXED", 1).freeze
        DELIMITED = new("DELIMITED", 2).freeze
      end

      optional(
        5,
        "message_encoding",
        type: :enum,
        enum_type: "google.protobuf.FeatureSet.MessageEncoding",
        json_name: "messageEncoding"
      )
      class JsonFormat
        extend Protobug::Enum

        self.full_name = "google.protobuf.FeatureSet.JsonFormat"

        JSON_FORMAT_UNKNOWN = new("JSON_FORMAT_UNKNOWN", 0).freeze
        ALLOW = new("ALLOW", 1).freeze
        LEGACY_BEST_EFFORT = new("LEGACY_BEST_EFFORT", 2).freeze
      end

      optional(
        6,
        "json_format",
        type: :enum,
        enum_type: "google.protobuf.FeatureSet.JsonFormat",
        json_name: "jsonFormat"
      )

      reserved_range(999...1000)
    end

    # A compiled specification for the defaults of a set of features.  These
    # messages are generated from FeatureSet extensions and can be used to seed
    # feature resolution. The resolution with this object becomes a simple search
    # for the closest matching edition, followed by proto merges.
    class FeatureSetDefaults
      extend Protobug::Message

      self.full_name = "google.protobuf.FeatureSetDefaults"

      # A map from every known edition with a unique set of defaults to its
      # defaults. Not all editions may be contained here.  For a given edition,
      # the defaults at the closest matching edition ordered at or before it should
      # be used.  This field must be in strict ascending order by edition.
      class FeatureSetEditionDefault
        extend Protobug::Message

        self.full_name = "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"

        optional(
          3,
          "edition",
          type: :enum,
          enum_type: "google.protobuf.Edition"
        )
        optional(
          2,
          "features",
          type: :message,
          message_type: "google.protobuf.FeatureSet"
        )
      end

      repeated(
        1,
        "defaults",
        type: :message,
        message_type:
        "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"
      )
      # The minimum supported edition (inclusive) when this was constructed.
      # Editions before this will not have defaults.
      optional(
        4,
        "minimum_edition",
        type: :enum,
        enum_type: "google.protobuf.Edition",
        json_name: "minimumEdition"
      )
      # The maximum known edition (inclusive) when this was constructed. Editions
      # after this will not have reliable defaults.
      optional(
        5,
        "maximum_edition",
        type: :enum,
        enum_type: "google.protobuf.Edition",
        json_name: "maximumEdition"
      )
    end

    # ===================================================================
    # Optional source code info

    # Encapsulates information about the original source file from which a
    # FileDescriptorProto was generated.
    class SourceCodeInfo
      extend Protobug::Message

      self.full_name = "google.protobuf.SourceCodeInfo"

      # A Location identifies a piece of source code in a .proto file which
      # corresponds to a particular definition.  This information is intended
      # to be useful to IDEs, code indexers, documentation generators, and similar
      # tools.
      #
      # For example, say we have a file like:
      #   message Foo {
      #     optional string foo = 1;
      #   }
      # Let's look at just the field definition:
      #   optional string foo = 1;
      #   ^       ^^     ^^  ^  ^^^
      #   a       bc     de  f  ghi
      # We have the following locations:
      #   span   path               represents
      #   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
      #   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
      #   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
      #   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
      #   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
      #
      # Notes:
      # - A location may refer to a repeated field itself (i.e. not to any
      #   particular index within it).  This is used whenever a set of elements are
      #   logically enclosed in a single code segment.  For example, an entire
      #   extend block (possibly containing multiple extension definitions) will
      #   have an outer location whose path refers to the "extensions" repeated
      #   field without an index.
      # - Multiple locations may have the same path.  This happens when a single
      #   logical declaration is spread out across multiple places.  The most
      #   obvious example is the "extend" block again -- there may be multiple
      #   extend blocks in the same scope, each of which will have the same path.
      # - A location's span is not always a subset of its parent's span.  For
      #   example, the "extendee" of an extension declaration appears at the
      #   beginning of the "extend" block and is shared by all extensions within
      #   the block.
      # - Just because a location's span is a subset of some other location's span
      #   does not mean that it is a descendant.  For example, a "group" defines
      #   both a type and a field in a single declaration.  Thus, the locations
      #   corresponding to the type and field and their components will overlap.
      # - Code which tries to interpret locations should probably be designed to
      #   ignore those that it doesn't understand, as more types of locations could
      #   be recorded in the future.
      repeated(
        1,
        "location",
        type: :message,
        message_type: "google.protobuf.SourceCodeInfo.Location"
      )
      class Location
        extend Protobug::Message

        self.full_name = "google.protobuf.SourceCodeInfo.Location"

        # Identifies which part of the FileDescriptorProto was defined at this
        # location.
        #
        # Each element is a field number or an index.  They form a path from
        # the root FileDescriptorProto to the place where the definition appears.
        # For example, this path:
        #   [ 4, 3, 2, 7, 1 ]
        # refers to:
        #   file.message_type(3)  // 4, 3
        #       .field(7)         // 2, 7
        #       .name()           // 1
        # This is because FileDescriptorProto.message_type has field number 4:
        #   repeated DescriptorProto message_type = 4;
        # and DescriptorProto.field has field number 2:
        #   repeated FieldDescriptorProto field = 2;
        # and FieldDescriptorProto.name has field number 1:
        #   optional string name = 1;
        #
        # Thus, the above path gives the location of a field name.  If we removed
        # the last element:
        #   [ 4, 3, 2, 7 ]
        # this path refers to the whole field declaration (from the beginning
        # of the label to the terminating semicolon).
        repeated(1, "path", type: :int32, packed: true)
        # Always has exactly three or four elements: start line, start column,
        # end line (optional, otherwise assumed same as start line), end column.
        # These are packed into a single field for efficiency.  Note that line
        # and column numbers are zero-based -- typically you will want to add
        # 1 to each before displaying to a user.
        repeated(2, "span", type: :int32, packed: true)
        # If this SourceCodeInfo represents a complete declaration, these are any
        # comments appearing before and after the declaration which appear to be
        # attached to the declaration.
        #
        # A series of line comments appearing on consecutive lines, with no other
        # tokens appearing on those lines, will be treated as a single comment.
        #
        # leading_detached_comments will keep paragraphs of comments that appear
        # before (but not connected to) the current element. Each paragraph,
        # separated by empty lines, will be one comment element in the repeated
        # field.
        #
        # Only the comment content is provided; comment markers (e.g. //) are
        # stripped out.  For block comments, leading whitespace and an asterisk
        # will be stripped from the beginning of each line other than the first.
        # Newlines are included in the output.
        #
        # Examples:
        #
        #   optional int32 foo = 1;  // Comment attached to foo.
        #   // Comment attached to bar.
        #   optional int32 bar = 2;
        #
        #   optional string baz = 3;
        #   // Comment attached to baz.
        #   // Another line attached to baz.
        #
        #   // Comment attached to moo.
        #   //
        #   // Another line attached to moo.
        #   optional double moo = 4;
        #
        #   // Detached comment for corge. This is not leading or trailing comments
        #   // to moo or corge because there are blank lines separating it from
        #   // both.
        #
        #   // Detached comment for corge paragraph 2.
        #
        #   optional string corge = 5;
        #   /* Block comment attached
        #    * to corge.  Leading asterisks
        #    * will be removed. */
        #   /* Block comment attached to
        #    * grault. */
        #   optional int32 grault = 6;
        #
        #   // ignored detached comments.
        optional(
          3,
          "leading_comments",
          type: :string,
          json_name: "leadingComments"
        )
        optional(
          4,
          "trailing_comments",
          type: :string,
          json_name: "trailingComments"
        )
        repeated(
          6,
          "leading_detached_comments",
          type: :string,
          json_name: "leadingDetachedComments"
        )
      end
    end

    # Describes the relationship between generated code and its original source
    # file. A GeneratedCodeInfo message is associated with only one generated
    # source file, but may contain references to different source .proto files.
    class GeneratedCodeInfo
      extend Protobug::Message

      self.full_name = "google.protobuf.GeneratedCodeInfo"

      # An Annotation connects some span of text in generated code to an element
      # of its generating .proto file.
      repeated(
        1,
        "annotation",
        type: :message,
        message_type: "google.protobuf.GeneratedCodeInfo.Annotation"
      )
      class Annotation
        extend Protobug::Message

        self.full_name = "google.protobuf.GeneratedCodeInfo.Annotation"

        # Identifies the element in the original source .proto file. This field
        # is formatted the same as SourceCodeInfo.Location.path.
        repeated(1, "path", type: :int32, packed: true)
        # Identifies the filesystem path to the original source .proto.
        optional(2, "source_file", type: :string, json_name: "sourceFile")
        # Identifies the starting offset in bytes in the generated code
        # that relates to the identified object.
        optional(3, "begin", type: :int32)
        # Identifies the ending offset in bytes in the generated code that
        # relates to the identified object. The end offset should be one past
        # the last relevant byte (so the length of the text = end - begin).
        optional(4, "end", type: :int32)
        # Represents the identified object's effect on the element in the original
        # .proto file.
        class Semantic
          extend Protobug::Enum

          self.full_name = "google.protobuf.GeneratedCodeInfo.Annotation.Semantic"

          # There is no effect or the effect is indescribable.
          NONE = new("NONE", 0).freeze
          # The element is set or otherwise mutated.
          SET = new("SET", 1).freeze
          # An alias to the element is returned.
          ALIAS = new("ALIAS", 2).freeze
        end

        optional(
          5,
          "semantic",
          type: :enum,
          enum_type: "google.protobuf.GeneratedCodeInfo.Annotation.Semantic"
        )
      end
    end

    def self.register_descriptor_protos(registry)
      registry.register(Google::Protobuf::FileDescriptorSet)
      registry.register(Google::Protobuf::Edition)
      registry.register(Google::Protobuf::FileDescriptorProto)
      registry.register(Google::Protobuf::DescriptorProto)
      registry.register(Google::Protobuf::DescriptorProto::ExtensionRange)
      registry.register(Google::Protobuf::DescriptorProto::ReservedRange)
      registry.register(Google::Protobuf::ExtensionRangeOptions)
      registry.register(Google::Protobuf::ExtensionRangeOptions::Declaration)
      registry.register(
        Google::Protobuf::ExtensionRangeOptions::VerificationState
      )
      registry.register(Google::Protobuf::FieldDescriptorProto)
      registry.register(Google::Protobuf::FieldDescriptorProto::Type)
      registry.register(Google::Protobuf::FieldDescriptorProto::Label)
      registry.register(Google::Protobuf::OneofDescriptorProto)
      registry.register(Google::Protobuf::EnumDescriptorProto)
      registry.register(
        Google::Protobuf::EnumDescriptorProto::EnumReservedRange
      )
      registry.register(Google::Protobuf::EnumValueDescriptorProto)
      registry.register(Google::Protobuf::ServiceDescriptorProto)
      registry.register(Google::Protobuf::MethodDescriptorProto)
      registry.register(Google::Protobuf::FileOptions)
      registry.register(Google::Protobuf::FileOptions::OptimizeMode)
      registry.register(Google::Protobuf::MessageOptions)
      registry.register(Google::Protobuf::FieldOptions)
      registry.register(Google::Protobuf::FieldOptions::CType)
      registry.register(Google::Protobuf::FieldOptions::JSType)
      registry.register(Google::Protobuf::FieldOptions::OptionRetention)
      registry.register(Google::Protobuf::FieldOptions::OptionTargetType)
      registry.register(Google::Protobuf::FieldOptions::EditionDefault)
      registry.register(Google::Protobuf::OneofOptions)
      registry.register(Google::Protobuf::EnumOptions)
      registry.register(Google::Protobuf::EnumValueOptions)
      registry.register(Google::Protobuf::ServiceOptions)
      registry.register(Google::Protobuf::MethodOptions)
      registry.register(Google::Protobuf::MethodOptions::IdempotencyLevel)
      registry.register(Google::Protobuf::UninterpretedOption)
      registry.register(Google::Protobuf::UninterpretedOption::NamePart)
      registry.register(Google::Protobuf::FeatureSet)
      registry.register(Google::Protobuf::FeatureSet::FieldPresence)
      registry.register(Google::Protobuf::FeatureSet::EnumType)
      registry.register(Google::Protobuf::FeatureSet::RepeatedFieldEncoding)
      registry.register(Google::Protobuf::FeatureSet::Utf8Validation)
      registry.register(Google::Protobuf::FeatureSet::MessageEncoding)
      registry.register(Google::Protobuf::FeatureSet::JsonFormat)
      registry.register(Google::Protobuf::FeatureSetDefaults)
      registry.register(
        Google::Protobuf::FeatureSetDefaults::FeatureSetEditionDefault
      )
      registry.register(Google::Protobuf::SourceCodeInfo)
      registry.register(Google::Protobuf::SourceCodeInfo::Location)
      registry.register(Google::Protobuf::GeneratedCodeInfo)
      registry.register(Google::Protobuf::GeneratedCodeInfo::Annotation)
      registry.register(
        Google::Protobuf::GeneratedCodeInfo::Annotation::Semantic
      )
    end
  end
end
