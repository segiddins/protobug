require "syntax_tree"

module Protobug
  class Compiler
    def self.compile!(request)
      response = Google::Protobuf::Compiler::CodeGeneratorResponse.new
      begin
        new(request, response).compile!
      rescue StandardError => e
        response.error = e.full_message
      end
      response
    end

    include SyntaxTree::DSL

    def initialize(request, response)
      @request = request
      @response = response
    end

    attr_reader :request, :response

    def file_name(file)
      ruby_package = file.options.ruby_package if file.options.ruby_package?
      prefix = if ruby_package
                 ruby_package.split("::").map(&:downcase).join("/")
               else
                 file.package.split(".").map(&:downcase).join("/")
               end
      file.name.gsub(%r{^.*?([^/]+)\.proto$}, "#{prefix}/\\1.proto.pb.rb")
    end

    def module_name(file)
      return file.options.ruby_package if file.options.ruby_package?

      to_constant(file)
    end

    def to_constant(descriptor)
      case descriptor
      when Google::Protobuf::FileDescriptorProto
        pkg = descriptor
      else
        raise "Unknown descriptor type: #{descriptor.class}"
      end
      ruby_package = pkg.options.ruby_package if pkg.options.ruby_package?
      parts =
        if ruby_package
          ruby_package.split("::")
        else
          prefix = pkg.package.split(".").map(&:capitalize)
        end

      insert = parts.size

      while false && descriptor.parent
        parts.insert(insert, descriptor.name)
        descriptor = descriptor.parent
      end

      parts.join("::")
    end

    class Files
      def initialize
        @descs_by_name = {}
        @files_by_path = {}
        @num_files = 0
      end

      def register_file(f)
        @files_by_path[f.name] = f

        f = Descriptor.new(f, nil)
        f.message_type.each do |msg|
          msg = Descriptor.new(msg, f)
          @descs_by_name[msg.full_name] = f
        end
        f.enum_type.each do |msg|
          msg = Descriptor.new(msg, f)
          @descs_by_name[msg.full_name] = f
        end
      end
    end

    class Descriptor
      attr_reader :descriptor, :parent

      def initialize(descriptor, parent)
        @descriptor = descriptor
        @parent = parent
      end

      def full_name
        if parent
          "#{parent.full_name}.#{descriptor.name}"
        else
          descriptor.name
        end
      end

      def respond_to_missing?(name)
        super || descriptor.respond_to?(name)
      end

      def method_missing(name, *args, **kwargs, &blk)
        if descriptor.respond_to?(name)
          descriptor.send(name, *args, **kwargs, &blk)
        else
          super
        end
      end
    end

    def compile!
      response.supported_features |= Google::Protobuf::Compiler::CodeGeneratorResponse::Feature::FEATURE_PROTO3_OPTIONAL.value
      files = Files.new

      request.proto_file.each do |file|
        files.register_file(file)
      end

      request.proto_file.each do |file|
        file_out = Google::Protobuf::Compiler::CodeGeneratorResponse::File.new
        file_out.name = file_name(file)
        file_out.content = file_contents(file)
        response.add_file(file_out)
      end
    end

    def file_contents(file)
      requires = Statements(
        file.dependency.map do |dep|
          Command(
            Ident("require"),
            Args([Lit("#{dep}.pb.rb")]), nil
          )
        end
      )

      mod = to_constant(file).split("::").reverse_each.reduce(declarations(file, file)) do |acc, elem|
        # ModuleDeclaration(ConstRef(Const(elem)),
        #                   BodyStmt(Statements([acc]), nil, nil, nil, nil))
        Module_(elem) { |stmts| stmts.body << acc }
      end
      program = Program(
        Statements([
                     Comment_("frozen_string_literal: true"),
                     Comment_("Code generated by protoc-gen-protobug. DO NOT EDIT."),
                     Statements([VoidStmt()]),
                     Statements([VoidStmt()]), # TODO: deleteq
                     Comment_("source: #{file.name}"),
                     Comment_("syntax: #{file.syntax? ? file.syntax : "proto2"}"),
                     Comment_("package: #{file.package}"),
                     Comment_("options:"),
                     *file.options.class.fields_by_name.map do |name, _field|
                       next unless file.options.send(:"#{name}?")

                       Comment_("   #{name}: #{file.options.send(name).inspect}") # TODO: name for enums
                     end.compact,
                     Statements([VoidStmt()]),
                     *source_loc(file, file).leading_detached_comments.map do |c|
                       Comment_(c)
                     end,
                     *source_loc(file, file).leading_comments&.then { Comment_(_1) unless _1.empty? },
                     Statements([VoidStmt()]),
                     Command(Ident("require"), Args([Lit("protobug")]), nil),
                     Statements([VoidStmt()]),
                     requires,
                     Statements([VoidStmt()]),
                     mod
                   ])
      )

      SyntaxTree.format_node("", program, 500)
    end

    def declarations(file, parent)
      statements = Statements([VoidStmt()])

      message_type = parent.respond_to?(:nested_type) ? parent.nested_type : parent.message_type
      message_type.each do |msg|
        loc = source_loc(file, msg)
        if loc&.leading_detached_comments?
          loc.leading_detached_comments.each do |c|
            statements.body << Comment_(c)
          end
          statements.body << Statements([VoidStmt()])
        end
        statements.body << Comment_(loc.leading_comments) if loc&.leading_comments?
        statements.body << Class_(msg.name) do |st|
          st.body << Command(Ident("extend"), Args([ConstRef(Const("Protobug::Message"))]), false)
          st.body << Statements([VoidStmt()])

          st.body << OpAssign(
            CallNode(Ident("self"), Op("."), Ident("full_name"), VoidStmt()),
            Op("="),
            Lit("#{msg.name}")
          )
          st.body << Statements([VoidStmt()])

          st.body << declarations(file, msg)



          msg.field.each do |field|
            loc = source_loc(file, field)
            if loc&.leading_detached_comments?
              loc.leading_detached_comments.each do |c|
                st.body << Comment_(c)
              end
              st.body << Statements([VoidStmt()])
            end
            st.body << Comment_(loc.leading_comments) if loc&.leading_comments?
            st.body << CallNode(
              nil, nil,
              Ident(
                case field.label
                when Google::Protobuf::FieldDescriptorProto::Label::LABEL_OPTIONAL
                  "optional"
                when Google::Protobuf::FieldDescriptorProto::Label::LABEL_REPEATED
                  "repeated"
                when Google::Protobuf::FieldDescriptorProto::Label::LABEL_REQUIRED
                  "required"
                end
              ),
              ArgParen(Args([
                              Lit(field.number),
                              Lit(field.name),
                              BareAssocHash([
                                              Assoc(Label("type:"),
                                                    SymbolLiteral(Ident(field.type.name.downcase.delete_prefix("type_"))))
                                            ]).tap do |bah|
                                              if field.type_name?
                                                bah.assocs << Assoc(Label("message_type:"), # TODO: enum type
                                                                    Lit(field.type_name.delete_prefix(".")))
                                              end
                                              if field.json_name? && field.json_name != field.name
                                                bah.assocs << Assoc(Label("json_name:"),
                                                                    Lit(field.json_name))
                                              end
                                              if field.oneof_index?
                                                bah.assocs << Assoc(Label("oneof:"),
                                                                    SymbolLiteral(Ident(msg.oneof_decl[field.oneof_index].name)))
                                              end
                                            end
                            ]))
            )
          end
        end
      end

      parent.enum_type.each do |enum|
        loc = source_loc(file, enum)
        if loc&.leading_detached_comments?
          loc.leading_detached_comments.each do |c|
            statements.body << Comment_(c)
          end
          statements.body << Statements([VoidStmt()])
        end
        statements.body << Comment_(loc.leading_comments) if loc&.leading_comments?
        statements.body << Class_(enum.name) do |st|
          st.body << Command(Ident("extend"), Args([ConstRef(Const("Protobug::Enum"))]), false)
          st.body << Statements([VoidStmt()])

          st.body << OpAssign(
            CallNode(Ident("self"), Op("."), Ident("full_name"), VoidStmt()),
            Op("="),
            Lit("")
          )

          st.body << Statements([VoidStmt()])

          enum.value.each do |value|
            loc = source_loc(file, value)
            if loc&.leading_detached_comments?
              loc.leading_detached_comments.each do |c|
                st.body << Comment_(c)
              end
              st.body << Statements([VoidStmt()])
            end
            st.body << Comment_(loc.leading_comments) if loc&.leading_comments?
            st.body << Assign(
              CVar(value.name),
              CallNode(
                CallNode(nil, nil, Ident("new"), ArgParen(Args([
                                                                 Lit(value.name),
                                                                 Lit(value.number)
                                                               ]))),
                Op("."),
                Ident("freeze"), VoidStmt()
              )
            )
          end
        end
      end

      statements
    end

    def Module_(name, &blk)
      ModuleDeclaration(ConstRef(Const(name)), BodyStmt(Statements([]).tap(&blk), nil, nil, nil, nil))
    end

    def Class_(name, scls = nil, &blk)
      ClassDeclaration(ConstRef(Const(name)), scls, BodyStmt(Statements([]).tap(&blk), nil, nil, nil, nil))
    end

    def Comment_(comment) # TODO: split into lines, each line is its own comment node
      comment = comment.rstrip
      unless comment.start_with?("#")
        has_space = comment.start_with?(" ")

        comment.gsub!(/^([^\n])?(?!\z)/m) do |m|
          if m
            "##{has_space ? "" : " "}#{m}"
          else
            "#"
          end
        end
      end
      Comment(comment, false)
    end

    def Lit(x)
      case x
      when String
        StringLiteral([TStringContent(x)], '"')
      when Integer
        Int(x.to_s)
      else
        raise
      end
    end

    def source_loc(file, descriptor)
      case descriptor
      when Google::Protobuf::FileDescriptorProto
        return file.source_code_info.location[1]
      else
        # exhaustive search

        path = path_descend([], file,
                            descriptor) || raise("Failed to find source loc for #{descriptor.inspect} (#{path})")
      end

      file.source_code_info.location.find do |loc|
        loc.path == path
      end
    end

    def path_descend(path, object, target)
      return unless object
      return path if object == target

      object.class.fields_by_number.each do |num, field|
        next unless field.type == :message

        if field.repeated?
          ary = object.send(field.name)
          ary.each_with_index do |v, idx|
            r = path_descend(path + [num, idx], v, target)
            return r if r
          end
        else
          r = path_descend(path + [num], object.send(field.name), target)
          return r if r
        end
      end
      nil
    end
  end
end
